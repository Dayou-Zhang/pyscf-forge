#!/usr/bin/env python
# Copyright 2014-2022 The PySCF Developers. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
from pyscf.lib import logger
from pyscf.dft2.libxc import XCFunctional
from pyscf import dft
import numpy as np
import copy


def f_v1(occ):
    return (occ * (3.0 - occ)), (occ * (-1.0 + occ))

def get_f_v2_m(m):
    def f(occ):
        c = (1/m + m - np.sqrt(2 + m**(-2) + m**2 + 4*(-2 + occ)*occ))/2.
        return (occ + c), (occ - c)
    return f

f_v2 = get_f_v2_m(0.96)

def get_converted_rho(natorb, occ, ao, xctype_id, f=f_v2):
    '''  Calculate rho used in eval_xc
         This rho may contain the converted density, density derivitive, and kinetic
         energy density.

        Args:
            natorb : ndarray of shape (nao, nao)
                generated by natorb
            occ : ndarray with shape (nao,)
                occupation numbers of natorb
            ao : ndarray of shape (ngrids, nao) for LDA or (4, ngrids, nao) for GGA
                and MGGA
                magnitude of atomic basis function [and gradients]
            xctype_id : int
                0 for LDA; 1 for GGA; 2 for MGGA

        Returns : two ndarrays with shape (ngrids,) for LDA or (4, ngrids) for GGA
            or (6, ngrids) for MGGA
            This varible may be passed to eval_xc to evaluate the nonclassical energy
    '''
    natorb = natorb.T

    if ao.ndim == 3:  # GGA
        ao_magnitude = ao[0]
        ao_magnitude_grad = ao[1:4]
    else:  # LDA
        ao_magnitude = ao

    # phi is the Magnitude of natural orbital and gradient
    phi = natorb @ ao_magnitude.T

    c_a, c_b = f(occ)
    phi_squared = phi * phi
    rho_a = phi_squared.T @ c_a * 0.5
    rho_b = phi_squared.T @ c_b * 0.5
    if xctype_id >= 1: # grad for GGA and MGGA
        phi_grad = natorb @ ao_magnitude_grad.transpose((0,2,1))
        phi_phigrad = phi[None, :, :] * phi_grad
        rhog_a = phi_phigrad.transpose((0,2,1)) @ c_a
        rhog_b = phi_phigrad.transpose((0,2,1)) @ c_b
        if xctype_id >= 2: # tau for MGGA
            phigrad_phigrad = phi_grad * phi_grad
            tau_a = np.einsum('a,dag->g', c_a, phigrad_phigrad)
            tau_b = np.einsum('a,dag->g', c_b, phigrad_phigrad)
    if xctype_id == 1:
        return (np.vstack((rho_a[None, :], rhog_a)),
                np.vstack((rho_b[None, :], rhog_b)))
    if xctype_id == 2:
        laplacian_dummy = np.zeros_like(tau_a)
        return (np.vstack((rho_a[None, :], rhog_a, laplacian_dummy, tau_a[None, :])),
                np.vstack((rho_b[None, :], rhog_b, laplacian_dummy, tau_b[None, :])))
    if xctype_id == 0:
        return (rho_a, rho_b)

class convfnal:
    def __init__ (self, mol, xc_code, hyb_x=0., display_name=None, grids_level=None, verbose=0, **kwargs):
        self.mol = mol
        self.dcxc = xc_code
        self.hyb_x = hyb_x
        self.display_name = 'c' + xc_code if display_name is None else display_name
        xcfunc = XCFunctional(xc_code, 1)
        ni = dft.numint.NumInt()
        ni.eval_xc = xcfunc.eval_xc
        ni.hybrid_coeff = lambda *x: 0.
        ni.rsh_coeff = lambda *x: (0., 0., 0.)
        ni._xc_type = xcfunc.xc_type_
        self._numint = ni
        self.xcfunc = xcfunc
        self.xctype = xcfunc.xc_type()
        self.dens_deriv = ['LDA', 'GGA', 'MGGA'].index(self.xctype)
        self.grids = dft.grid.Grids(mol)
        if grids_level is not None:
            if isinstance(grids_level, int):
                self.grids.level = grids_level
            elif isinstance(grids_level, tuple):
                self.grids.atom_grid = grids_level
        self.grids.build()
        self.xcfunc = xcfunc
        self.get_converted_rho = get_converted_rho
        self.get_converted_rho_args = dict(f=f_v1)
        self.verbose = verbose
        if self.verbose >= logger.DEBUG:
            self.ms = 0.0

    def get_E_dc(self, natorb, occ, ao, weight):
        ''' E_xc[dm] = V_xc[rho_converted]

            Args:
                rho : ndarray of shape (2,*,ngrids)
                    containing spin-density [and derivatives]
                D : ndarray with shape (4, ngrids)
                    containing unpaired density and derivatives
                weight : ndarray of shape (ngrids)
                    containing numerical integration weights

            Returns : float
                The on-top exchange-correlation energy, for an on-top xc functional
                which uses a translated density with an otherwise standard xc functional
        '''
        #  assert (rho.shape[-1] == D.shape[-1]), f"rho.shape={rho.shape}, D.shape={D.shape}"
        #  if rho.ndim == 2:
            #  rho = np.expand_dims(rho, 1)

        rho_c = self.get_converted_rho(natorb, occ, ao, self.dens_deriv, **self.get_converted_rho_args)

        dexc_ddens = self._numint.eval_xc(
            rho_c, spin=1, relativity=0, deriv=0, verbose=self.verbose)[0]
        rho = rho_c[0][0] + rho_c[1][0]
        rho *= weight
        dexc_ddens *= rho

        if self.verbose >= logger.DEBUG:
            ms = np.dot(rho_c[0,0,:] - rho_c[1,0,:], weight) * 0.5
            self.ms += ms
            nelec = rho.sum()
            logger.debug(self, 'MC-DCFT: Total number of electrons in (this chunk of) the total density = %s', nelec)
            logger.debug(self,
                         'MC-DCFT: Total ms = (neleca - nelecb) / 2 in (this chunk of) the translated density = %s',
                         ms)

        return dexc_ddens.sum()

